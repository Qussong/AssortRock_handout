1. 가상함수 동작원리에 대해서 그림과 글을 이용하여 설명하시오.

가상 함수를 구현하는 방법은 함수의 리터 타입 앞에 virtual 키워드를 붙여주면 된다.
가상 함수를 구현하게 되면 각 클래스에는 가상 테이블이 생성되며,
보이진 않지만, 클래스에 가상 테이블을 가리키는 포인터 변수가 생성된다.

부모 클래스는 자식 클래스의 객체를 받을 수 있으며
만약 A Class 의 멤버 함수로 가상 함수가 존재하고 B Class 가 A 클래스를 상속받았고,
A* ab = new B(); 의 형태로 A 객체를 생성하였다면
객체 ab에 존재하는 가상함수를 호출 했을 때 클래스를 구현한 각 객체의 주소가 들어있는 가상테이블을 기반으로  A 클래스가 아닌 B 클래스에 오버로딩 되어 있는 함수를 호출한다.

ex)
class A
{
public:
	virtual void print()
	{
		cout << "I'm A" << endl;
	}
};

class B : public A
{
public:
	void print()
	{
		cout << "I'm B" << endl;
	}
};

int main(void)
{
	A* a = new A();
	B* b = new B();
	A* ab = new B();

	a->print();		// I'm A
	b->print();		// I'm B
	ab->print();	// I'm B

	return 0;
}


2. 프로세스와 스레드의 차이점에 대해서 설명하시오.
프로세스란 하나의 실행되는 프로그램이며,
스레드는 동시에 실행할 수 있는 프로그램(프로세스)의 개수를 의미한다.

3. 추상 클래스는 무엇이며 왜 사용 하는가?
추상 클래스란 상속되길 기대하는 클래스로서,
파생(자식) 클래스에 의해 구체화된다.
추상클래스로는 객체를 생성할 수 없으며,
순수 가상함수가 하나로 존재하면 추상 클래스가 된다.
또한, 추상클래스를 사용하는 이유는 설계시 특정 기능이나 함수의 네이밍을 강제하기 위함이다.

4. 학원에서 가장 어려웠던 과목은 무엇이며 이유는 무엇인가?
알고리즘 입니다.
왜냐하면 알지못하면 절대 풀수 없는 형태가 있다보니,
문법을 다 안다고 할지라도 처음 접하는 알고리즘 문제를 접하게되면 열심히 공부했을지라도
많은 시간이 걸리거나, 풀지 못할 수 있기 때문이다.
하지만 그렇기 때문에 새로운 알고리즘을 접할때마다 하나씩 배워간다는 성취감이 들어 재미있었습니다.

5. 상속구조에서 소멸자에 virtual 을 사용해야 하는 이유가 무엇인가?
부모 클래스는 자식 클래스를 받을 수 있는데 이 때 virtual 키워드를 붙이지 않으면
해당 객체가 메모리 해제 될때 부모 클래스의 소멸자가 호출 되어 자식 클래스에 존재하는 멤버들이 제대로 
메모리 해제가 되지 않을 수 있기 때문에 부모 클래스의 소멸자에는 반드시 virtual 키워드를 붙여줘야 한다.
+
다형성 때문
다형성을 이용한 설계는 거의 대부분의 경우 부모 타입 주소로 들고 있게 되구, 해제도 그상태에서 바로 해버리는데 그렇게 되면 virtual 안달린 경우에는 자식 소멸자가 호출이 안됨
 
5. 바이트 패딩에 대해서 설명하고 바이트패딩을 사용하는 이유에 대해서 설명하시오.
바이트 패딩이란 클래스에 존재하는 멤버들 중 가장 큰 멤버의 바이트 수를 기준으로 클래스가 할당 하는 메모리 사이즈가 증가 하는 것으로, 이를 사용하는 이유는 CPU가 메모리를 읽어올 때 일정한 사이즈로 메모리를 읽어 오게 함으로 성능을 향상시키기 위함이다.

+ 
구조체 멤버 맞춤이라는 옵션 설정 할 수 있구,
pragma pack으로 조정 할 수 있다고 추가 하면 더 좋겠어

6. 멤버함수 동작원리에 대해서 설명하시오.
멤버함수는 클래스 내에 존재하는 함수를 뜻한다.
하나의 클래스로 여러개의 객체를 생성할 수 있는데 각 객체마다 멤버 변수들의 값이 다를 수 있기에
각 객체마다 멤버함수가 반환하는 값은 달라질 수 있다.
이 때 멤버함수가 각 객체를 잘 찾아 갈 수 있는 이유는 함수의 파라미터에 생략되어 있지만 this 포인터가 존재하기 때문이다. 멤버 함수는 this 포인터에 들어 있는 각 객체의 주소를 기반으로 데이터를 찾아온다.
(this 포인터의 형태 : const 클래스 * const this)
+ 특정 객체의 멤버 함수 포인터 핸들링 추가할 것
