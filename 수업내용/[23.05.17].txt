[23/05/17]

---[질문]---

[문제유형]
1~15 : 기초문버
16~30 : 자료구조
30~40 : ???

[참고사이트_프로그래머스]
프로그래머스 -> 코딩테스트연습 -> 고득점Kit : 해당 영역에 있는것만 끝내면 된다.

[게임포폴]
- 위자드오브레전드

[size_t]
- unsigned __int64

[포인터]
- ex)
int num = 10;
int* pNum = &num;
*pNum++;	// pNum -> (pNum+1) 에 접근한다 , 주소값을 증가시킨다. = *(pNum++)
(*pNum)++;	// num = 10 -> num = 11 , 주소가 가리키고 있는 변수의 값을 증가
- 연산자 우선순위를 찹고해보자
	단항 연산자가 제일 위에 있다.

---[1교시]---

[2중 while문]

[정렬]
1) 선택 정렬
- 오름차순 : 5,3,6,1,2,8 -> 1,2,3,5,6,8
	arr[0] -> arr[1], arr[2], arr[3], arr[5], .... 과 비교
	arr[1] -> arr[2], arr[3], arr[5], .... 과 비교
	arr[2] -> arr[3], arr[5], .... 과 비교
	arr[3] -> arr[5], .... 과 비교
	...
	arr[n] : 마지막 원소에 도달하면 종료
- 배열에서 최소값 최대값을 찾을 때 계산할 필요없이 정렬해두고 찾아주면 된다.

2) 버블정렬
- 선택정렬과 비슷하다

- 사용하는 알고리즘에는 정답이 없긴하나 상황에 따라 적절한 선택지가 존재하긴 한다.
	상황에 따라 빠른 알고리즘을 선택할 뿐이지 특정 알고리즘이 무조건 좋다와 같은건 없다.
	
[STL_sort]

[2차원 배열]
int arr2D[3][3]; 이 존재할 때...
	arr[0] = &arr[0][0]; -> 2차원 배열의 0행에 해당하는 값에 전부 접근가능하다
	arr[1] = &arr[1][0]; -> 2차원 배열의 1행에 해당하는 값에 전부 접근가능하다
	arr[2] = &arr[2][0]; -> 2차원 배열의 2행에 해당하는 값에 전부 접근가능하다
	
[★중요사항★]
- 버그가 발생했을 때 안좋은 예시 : 
	1. 
	될때까지 소스코드를 수정해보면서 마구 f5를 누르면서 실행시켜본다.
	-> 전체적인 내용을 이해하고 프로그래밍을 하는게 아니라 찍어서 프로그래맹 하는거다.
	즉, 추리없이 기억에 의존해서 프로그래밍 하는것
	
	2.
	소스코드를 눈으로 버그를 찾는다.
	매우 간단한 소스코드는 눈으로 찾아도 된다.
	하지만 점점 소스코드가 길어지고 복잡해 질수록 버기 찾기가 어려워진다.
	눈과 머리로 모두를 기억할 수 없다.
	디버깅없이 버그를 찾아내면 안된다. f10, f11, f9, ctrl+f10 + 조사식

- 좋은 예시 : 
	한줄씩 실행해가면서 f10 누르고 해당줄 코드 머리속으로 생각해보고 추리, 유추 하고
	한줄씩 실행하기
	최종결과까지도 너부 한줄씩 연습해본다.

[비교]
char cmp1[256] = "HELLO";
char cmp2[256] = "HELLT";

// case1
if(cmp1 == cmp2)	// 절대 false가 나온다.
{					// 왜냐하면 저렇게 비교르 하게되면 주소를 비교하게되는건데
					// 주소값은 절대 같을 수가 없기 때문이다.
}					// 우리는 해당 주소에 있는 값을 비교하고자 하는거다.

// 아래와 같이 for문을 돌려가며 비교해야한다.
// case2
int flag = 0;
for(int i =0; i < 256; ++i)
{
	if(cmp1[i] != cmp2[i])
		flag = 1;
}

if(flag)
	cout << "같다";
else
	cout << "다르다";