[23/05/23]

---[질문]---
- 해시테이블의 단점 : 메모리 낭비
- 리팩토링

---[1교시]---

[메모리]
-영역 분류 : 
	1. 코드 영역 : 작성한 소스 코드가(바이너리 코드 형태로) 올라가는 영역
	2. 데이터 영역 : 전역변수가 들어가는 영역, 클래스에서 전역변수처럼 사용되는 static 변수도 이에 해당
	3. 힙 영역 : 동적할당되는 변수가 위치하는 영역
	4. 스택 영역 : 지역변수가 위치하는 영역
- 메모리 영역별로 크기가 정해져있다.
	때문에 지역변수도 무작정 많이 만들면 stackover flow가 발생한다.
- 속성 -> 링커 -> 시스템 -> 스택 예약 크기 -> Byte 단위(1MB이내로 설정하길 추천)

[클래스]
- 구조체는 빠르게 접근해야하는 공통 데이터에 사용되는
- 왠만한건 대부분 클래스로 만든다
- 클래스는 멤버 생성시 접근 제한자의 기본값이 private 

[동적할당]
- char arr[256] = {};
	위와같이 배열을 생성하게되면 프로그램 실행시 설정해준 크기로 크기가 정해져버린다.
	원하지 않아도 정해져 있는 크기기에 계속 쌓이게되면 메모리 낭비가 될 수 있다.
- 이에 대한 해결책으로 나온게 '동적할당'
- 원할 때 크기를 정해서 메모리에 할당 할 수 있다.

1. malloc
- 형태 : malloc(메모리 사이즈);
- 바이트 단위
- memory allocate
- 할당한 메모리의 주소를 반환한다.
- void* (보이드형 포인터)를 반환하기에 할당해줄때 형변환을 해줘야 한다.
	ex)
		int* pnum = (int*)malloc(4*10);
		// int형 변수 10개가 들어갈 수 있는 공간의 주소	
		// 즉, 배열의 크기 동적 할당 해준 형태
- 자료형 마다 사이즈를 다 외우기 힘들기에 4,1 과 같은 정수형 값이 아니라
	sizeof(int), sizeof(char) 등과 같이 적는다.
	ex)
		int cnt = 10;
		int* dynamicArr = malloc(sizeof(int) * cnt);
		
2. new
- malloc 이 사용하기 불편해서 c++에서 새로 만든 '동적할당 연산자'
- 형태 : new 자료형[자료형의 크기]
	ex)
		int cnt = 10;
		int* ppDynamicArr = new int[cnt];
- 장점 : 자동 형변환

[동적할당의 단점]
- 메모리를 직접 원하는만큼 할당했으니...
	프로그램이 종료되기전에 메모리 해제도 직접 해줘야한다.
- 해제 해주지 않으면 '메모리 릭'이 발생한다.
- c 스타일 : free('동적할당 해준 변수 명')
- cpp 스타일 : delete '동적할당 해준 변수 명'
- fd fd fd fd : 팬스 메모리, 항상 양쪽으로 4Byte씩 잡힌다, fd는 별 의미 없다.


---[2교시]---

